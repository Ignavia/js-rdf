<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/n3/n3Parser.js | JavaScript RDF API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  <a href="./manual/index.html" data-ice="manualHeaderLink">Manual</a>
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/Ignavia/js-rdf.git" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/BlankNode.js~BlankNode.html">BlankNode</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Graph.js~Graph.html">Graph</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Literal.js~Literal.html">Literal</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/NamedNode.js~NamedNode.html">NamedNode</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/PrefixMap.js~PrefixMap.html">PrefixMap</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Profile.js~Profile.html">Profile</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/RDFEnvironment.js~RDFEnvironment.html">RDFEnvironment</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/RDFNode.js~RDFNode.html">RDFNode</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/TermMap.js~TermMap.html">TermMap</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Triple.js~Triple.html">Triple</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/TurtleReader.js~TurtleReader.html">TurtleReader</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/TurtleWriter.js~TurtleWriter.html">TurtleWriter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-xmlSchemaTypes">xmlSchemaTypes</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">n3</div><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-N3Lexer">N3Lexer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-N3Parser">N3Parser</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/n3/n3Parser.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">// **N3Parser** parses N3 documents.
import N3Lexer from &quot;./n3Lexer.js&quot;;

var RDF_PREFIX = &apos;http://www.w3.org/1999/02/22-rdf-syntax-ns#&apos;,
    RDF_NIL    = RDF_PREFIX + &apos;nil&apos;,
    RDF_FIRST  = RDF_PREFIX + &apos;first&apos;,
    RDF_REST   = RDF_PREFIX + &apos;rest&apos;;

var absoluteIRI = /^[a-z][a-z0-9+.-]*:/i,
    schemeAuthority = /^(?:([a-z][a-z0-9+.-]*:))?(?:\/\/[^\/]*)?/i,
    dotSegments = /(?:^|\/)\.\.?(?:$|[\/#?])/;

// The next ID for new blank nodes
var blankNodePrefix = 0, blankNodeCount = 0; // TODO: remove blank node prefix

// ## Constructor
function N3Parser(options) {
  if (!(this instanceof N3Parser))
    return new N3Parser(options);
  this._tripleStack = [];
  this._graph = null;

  // Set the document IRI.
  options = options || {};
  this._setBase(options.documentIRI);

  // Set supported features depending on the format.
  var format = (typeof options.format === &apos;string&apos;) &amp;&amp; options.format.match(/\w*$/)[0].toLowerCase(),
      isTurtle = format === &apos;turtle&apos;, isTriG = format === &apos;trig&apos;,
      isNTriples = /triple/.test(format), isNQuads = /quad/.test(format),
      isLineMode = isNTriples || isNQuads;
  if (!(this._supportsNamedGraphs = !isTurtle))
    this._readPredicateOrNamedGraph = this._readPredicate;
  this._supportsQuads = !(isTurtle || isTriG || isNTriples);
  // Disable relative IRIs in N-Triples or N-Quads mode
  if (isLineMode) {
    this._base = &apos;&apos;;
    this._resolveIRI = function (token) {
      this._error(&apos;Disallowed relative IRI&apos;, token);
      return this._callback = noop, this._subject = null;
    };
  }
  this._blankNodePrefix = typeof options.blankNodePrefix !== &apos;string&apos; ? &apos;&apos; :
                            &apos;_:&apos; + options.blankNodePrefix.replace(/^_:/, &apos;&apos;);
  this._lexer = options.lexer || new N3Lexer({ lineMode: isLineMode });
}

// ## Private class methods

// ### `_resetBlankNodeIds` restarts blank node identification.
N3Parser._resetBlankNodeIds = function () {
  blankNodePrefix = blankNodeCount = 0;
};

N3Parser.prototype = {
  // ## Private methods

  // ### `_setBase` sets the base IRI to resolve relative IRIs.
  _setBase: function (baseIRI) {
    if (!baseIRI)
      baseIRI = null;
    else if (baseIRI.indexOf(&apos;#&apos;) &gt;= 0)
      throw new Error(&apos;Invalid base IRI &apos; + baseIRI);
    // Set base IRI and its components
    if (this._base = baseIRI) {
      this._basePath   = baseIRI.replace(/[^\/?]*(?:\?.*)?$/, &apos;&apos;);
      baseIRI = baseIRI.match(schemeAuthority);
      this._baseRoot   = baseIRI[0];
      this._baseScheme = baseIRI[1];
    }
  },

  // ### `_readInTopContext` reads a token when in the top context.
  _readInTopContext: function (token) {
    switch (token.type) {
    // If an EOF token arrives in the top context, signal that we&apos;re done.
    case &apos;eof&apos;:
      if (this._graph !== null)
        return this._error(&apos;Unclosed graph&apos;, token);
      delete this._prefixes._;
      return this._callback(null, null, this._prefixes);
    // It could be a prefix declaration.
    case &apos;@prefix&apos;:
      this._sparqlStyle = false;
      return this._readPrefix;
    case &apos;PREFIX&apos;:
      this._sparqlStyle = true;
      return this._readPrefix;
    // It could be a base declaration.
    case &apos;@base&apos;:
      this._sparqlStyle = false;
      return this._readBaseIRI;
    case &apos;BASE&apos;:
      this._sparqlStyle = true;
      return this._readBaseIRI;
    // It could be a graph.
    case &apos;{&apos;:
      if (this._supportsNamedGraphs) {
        this._graph = &apos;&apos;;
        this._subject = null;
        return this._readSubject;
      }
    case &apos;GRAPH&apos;:
      if (this._supportsNamedGraphs)
        return this._readNamedGraphLabel;
    // Otherwise, the next token must be a subject.
    default:
      return this._readSubject(token);
    }
  },

  // ### `_readSubject` reads a triple&apos;s subject.
  _readSubject: function (token) {
    this._predicate = null;
    switch (token.type) {
    case &apos;IRI&apos;:
      if (this._base === null || absoluteIRI.test(token.value))
        this._subject = token.value;
      else
        this._subject = this._resolveIRI(token);
      break;
    case &apos;prefixed&apos;:
      var prefix = this._prefixes[token.prefix];
      if (prefix === undefined)
        return this._error(&apos;Undefined prefix &quot;&apos; + token.prefix + &apos;:&quot;&apos;, token);
      this._subject = prefix + token.value;
      break;
    case &apos;[&apos;:
      // Start a new triple with a new blank node as subject.
      this._subject = &apos;_:b&apos; + blankNodeCount++;
      this._tripleStack.push({ subject: this._subject, predicate: null, object: null, type: &apos;blank&apos; });
      return this._readBlankNodeHead;
    case &apos;(&apos;:
      // Start a new list
      this._tripleStack.push({ subject: RDF_NIL, predicate: null, object: null, type: &apos;list&apos; });
      this._subject = null;
      return this._readListItem;
    case &apos;}&apos;:
      return this._readPunctuation(token);
    default:
      return this._error(&apos;Expected subject but got &apos; + token.type, token);
    }
    // The next token must be a predicate,
    // or, if the subject was actually a graph IRI, a named graph.
    return this._readPredicateOrNamedGraph;
  },

  // ### `_readPredicate` reads a triple&apos;s predicate.
  _readPredicate: function (token) {
    var type = token.type;
    switch (type) {
    case &apos;IRI&apos;:
    case &apos;abbreviation&apos;:
      if (this._base === null || absoluteIRI.test(token.value))
        this._predicate = token.value;
      else
        this._predicate = this._resolveIRI(token);
      break;
    case &apos;prefixed&apos;:
      if (token.prefix === &apos;_&apos;)
        return this._error(&apos;Disallowed blank node as predicate&apos;, token);
      var prefix = this._prefixes[token.prefix];
      if (prefix === undefined)
        return this._error(&apos;Undefined prefix &quot;&apos; + token.prefix + &apos;:&quot;&apos;, token);
      this._predicate = prefix + token.value;
      break;
    case &apos;.&apos;:
    case &apos;]&apos;:
    case &apos;}&apos;:
      // Expected predicate didn&apos;t come, must have been trailing semicolon.
      if (this._predicate === null)
        return this._error(&apos;Unexpected &apos; + type, token);
      this._subject = null;
      return type === &apos;]&apos; ? this._readBlankNodeTail(token) : this._readPunctuation(token);
    case &apos;;&apos;:
      // Extra semicolons can be safely ignored
      return this._readPredicate;
    default:
      return this._error(&apos;Expected predicate to follow &quot;&apos; + this._subject + &apos;&quot;&apos;, token);
    }
    // The next token must be an object.
    return this._readObject;
  },

  // ### `_readObject` reads a triple&apos;s object.
  _readObject: function (token) {
    switch (token.type) {
    case &apos;IRI&apos;:
      if (this._base === null || absoluteIRI.test(token.value))
        this._object = token.value;
      else
        this._object = this._resolveIRI(token);
      break;
    case &apos;prefixed&apos;:
      var prefix = this._prefixes[token.prefix];
      if (prefix === undefined)
        return this._error(&apos;Undefined prefix &quot;&apos; + token.prefix + &apos;:&quot;&apos;, token);
      this._object = prefix + token.value;
      break;
    case &apos;literal&apos;:
      this._object = token.value;
      return this._readDataTypeOrLang;
    case &apos;[&apos;:
      // Start a new triple with a new blank node as subject.
      var blank = &apos;_:b&apos; + blankNodeCount++;
      this._tripleStack.push({ subject: this._subject, predicate: this._predicate, object: blank, type: &apos;blank&apos; });
      this._subject = blank;
      return this._readBlankNodeHead;
    case &apos;(&apos;:
      // Start a new list
      this._tripleStack.push({ subject: this._subject, predicate: this._predicate, object: RDF_NIL, type: &apos;list&apos; });
      this._subject = null;
      return this._readListItem;
    default:
      return this._error(&apos;Expected object to follow &quot;&apos; + this._predicate + &apos;&quot;&apos;, token);
    }
    return this._getTripleEndReader();
  },

  // ### `_readPredicateOrNamedGraph` reads a triple&apos;s predicate, or a named graph.
  _readPredicateOrNamedGraph: function (token) {
    return token.type === &apos;{&apos; ? this._readGraph(token) : this._readPredicate(token);
  },

  // ### `_readGraph` reads a graph.
  _readGraph: function (token) {
    if (token.type !== &apos;{&apos;)
      return this._error(&apos;Expected graph but got &apos; + token.type, token);
    // The &quot;subject&quot; we read is actually the GRAPH&apos;s label
    this._graph = this._subject, this._subject = null;
    return this._readSubject;
  },

  // ### `_readBlankNodeHead` reads the head of a blank node.
  _readBlankNodeHead: function (token) {
    if (token.type === &apos;]&apos;) {
      this._subject = null;
      return this._readBlankNodeTail(token);
    }
    else {
      this._predicate = null;
      return this._readPredicate(token);
    }
  },

  // ### `_readBlankNodeTail` reads the end of a blank node.
  _readBlankNodeTail: function (token) {
    if (token.type !== &apos;]&apos;)
      return this._readBlankNodePunctuation(token);

    // Store blank node triple.
    if (this._subject !== null)
      this._callback(null, { subject:   this._subject,
                             predicate: this._predicate,
                             object:    this._object,
                             graph:     this._graph || &apos;&apos; });

    // Restore parent triple that contains the blank node.
    var triple = this._tripleStack.pop();
    this._subject = triple.subject;
    // Was the blank node the object?
    if (triple.object !== null) {
      // Restore predicate and object as well, and continue by reading punctuation.
      this._predicate = triple.predicate;
      this._object = triple.object;
      return this._getTripleEndReader();
    }
    // The blank node was the subject, so continue reading the predicate.
    // If the blank node didn&apos;t contain any predicates, it could also be the label of a named graph.
    return this._predicate !== null ? this._readPredicate : this._readPredicateOrNamedGraph;
  },

  // ### `_readDataTypeOrLang` reads an _optional_ data type or language.
  _readDataTypeOrLang: function (token) {
    switch (token.type) {
    case &apos;type&apos;:
      var value;
      if (token.prefix === &apos;&apos;) {
        if (this._base === null || absoluteIRI.test(token.value))
          value = token.value;
        else
          value = this._resolveIRI(token);
      }
      else {
        var prefix = this._prefixes[token.prefix];
        if (prefix === undefined)
          return this._error(&apos;Undefined prefix &quot;&apos; + token.prefix + &apos;:&quot;&apos;, token);
        value = prefix + token.value;
      }
      this._object += &apos;^^&apos; + value;
      return this._getTripleEndReader();
    case &apos;langcode&apos;:
      this._object += &apos;@&apos; + token.value.toLowerCase();
      return this._getTripleEndReader();
    default:
      return this._getTripleEndReader().call(this, token);
    }
  },

  // ### `_readListItem` reads items from a list.
  _readListItem: function (token) {
    var item = null,                  // The actual list item.
        itemHead = null,              // The head of the rdf:first predicate.
        prevItemHead = this._subject, // The head of the previous rdf:first predicate.
        stack = this._tripleStack,    // The stack of triples part of recursion (lists, blanks, etc.).
        parentTriple = stack[stack.length - 1], // The triple containing the current list.
        next = this._readListItem;    // The next function to execute.

    switch (token.type) {
    case &apos;IRI&apos;:
      if (this._base === null || absoluteIRI.test(token.value))
        item = token.value;
      else
        item = this._resolveIRI(token);
      break;
    case &apos;prefixed&apos;:
      var prefix = this._prefixes[token.prefix];
      if (prefix === undefined)
        return this._error(&apos;Undefined prefix &quot;&apos; + token.prefix + &apos;:&quot;&apos;, token);
      item = prefix + token.value;
      break;
    case &apos;literal&apos;:
      item = token.value;
      next = this._readDataTypeOrLang;
      break;
    case &apos;[&apos;:
      // Stack the current list triple and start a new triple with a blank node as subject.
      itemHead = &apos;_:b&apos; + blankNodeCount++;
      item     = &apos;_:b&apos; + blankNodeCount++;
      stack.push({ subject: itemHead, predicate: RDF_FIRST, object: item, type: &apos;blank&apos; });
      this._subject = item;
      next = this._readBlankNodeHead;
      break;
    case &apos;(&apos;:
      // Stack the current list triple and start a new list
      itemHead = &apos;_:b&apos; + blankNodeCount++;
      stack.push({ subject: itemHead, predicate: RDF_FIRST, object: RDF_NIL, type: &apos;list&apos; });
      this._subject = null;
      next = this._readListItem;
      break;
    case &apos;)&apos;:
      // Restore the parent triple.
      stack.pop();
      // If this list is contained within a parent list, return the membership triple here.
      // This will be `&lt;parent list element&gt; rdf:first &lt;this list&gt;.`.
      if (stack.length !== 0 &amp;&amp; stack[stack.length - 1].type === &apos;list&apos;)
        this._callback(null, { subject:   parentTriple.subject,
                               predicate: parentTriple.predicate,
                               object:    parentTriple.object,
                               graph:     this._graph || &apos;&apos; });
      // Restore the parent triple&apos;s subject.
      this._subject = parentTriple.subject;
      // Was this list in the parent triple&apos;s subject?
      if (parentTriple.predicate === null) {
        // The next token is the predicate.
        next = this._readPredicate;
        // Skip writing the list tail if this was an empty list.
        if (parentTriple.subject === RDF_NIL)
          return next;
      }
      // The list was in the parent triple&apos;s object.
      else {
        // Restore the parent triple&apos;s predicate and object as well.
        this._predicate = parentTriple.predicate;
        this._object = parentTriple.object;
        next = this._getTripleEndReader();
        // Skip writing the list tail if this was an empty list.
        if (parentTriple.object === RDF_NIL)
          return next;
      }
      // Close the list by making the item head nil.
      itemHead = RDF_NIL;
      break;
    default:
      return this._error(&apos;Expected list item instead of &quot;&apos; + token.type + &apos;&quot;&apos;, token);
    }

     // Create a new blank node if no item head was assigned yet.
    if (itemHead === null)
      this._subject = itemHead = &apos;_:b&apos; + blankNodeCount++;

    // Is this the first element of the list?
    if (prevItemHead === null) {
      // This list is either the object or the subject.
      if (parentTriple.object === RDF_NIL)
        parentTriple.object = itemHead;
      else
        parentTriple.subject = itemHead;
    }
    else {
      // The rest of the list is in the current head.
      this._callback(null, { subject:   prevItemHead,
                             predicate: RDF_REST,
                             object:    itemHead,
                             graph:     this._graph || &apos;&apos; });
    }
    // Add the item&apos;s value.
    if (item !== null)
      this._callback(null, { subject:   itemHead,
                             predicate: RDF_FIRST,
                             object:    item,
                             graph:     this._graph || &apos;&apos; });
    return next;
  },

  // ### `_readPunctuation` reads punctuation between triples or triple parts.
  _readPunctuation: function (token) {
    var next, subject = this._subject, graph = this._graph;
    switch (token.type) {
    // A closing brace ends a graph
    case &apos;}&apos;:
      if (this._graph === null)
        return this._error(&apos;Unexpected graph closing&apos;, token);
      this._graph = null;
    // A dot just ends the statement, without sharing anything with the next.
    case &apos;.&apos;:
      this._subject = null;
      next = this._readInTopContext;
      break;
    // Semicolon means the subject is shared; predicate and object are different.
    case &apos;;&apos;:
      next = this._readPredicate;
      break;
    // Comma means both the subject and predicate are shared; the object is different.
    case &apos;,&apos;:
      next = this._readObject;
      break;
    // An IRI means this is a quad (only allowed if not already inside a graph).
    case &apos;IRI&apos;:
      if (this._supportsQuads &amp;&amp; this._graph === null) {
        if (this._base === null || absoluteIRI.test(token.value))
          graph = token.value;
        else
          graph = this._resolveIRI(token);
        subject = this._subject;
        next = this._readQuadPunctuation;
        break;
      }
    // An prefixed name means this is a quad (only allowed if not already inside a graph).
    case &apos;prefixed&apos;:
      if (this._supportsQuads &amp;&amp; this._graph === null) {
        var prefix = this._prefixes[token.prefix];
        if (prefix === undefined)
          return this._error(&apos;Undefined prefix &quot;&apos; + token.prefix + &apos;:&quot;&apos;, token);
        graph = prefix + token.value;
        next = this._readQuadPunctuation;
        break;
      }
    default:
      return this._error(&apos;Expected punctuation to follow &quot;&apos; + this._object + &apos;&quot;&apos;, token);
    }
    // A triple has been completed now, so return it.
    if (subject !== null)
      this._callback(null, { subject:   subject,
                             predicate: this._predicate,
                             object:    this._object,
                             graph:     graph || &apos;&apos; });
    return next;
  },

    // ### `_readBlankNodePunctuation` reads punctuation in a blank node
  _readBlankNodePunctuation: function (token) {
    var next;
    switch (token.type) {
    // Semicolon means the subject is shared; predicate and object are different.
    case &apos;;&apos;:
      next = this._readPredicate;
      break;
    // Comma means both the subject and predicate are shared; the object is different.
    case &apos;,&apos;:
      next = this._readObject;
      break;
    default:
      return this._error(&apos;Expected punctuation to follow &quot;&apos; + this._object + &apos;&quot;&apos;, token);
    }
    // A triple has been completed now, so return it.
    this._callback(null, { subject:   this._subject,
                           predicate: this._predicate,
                           object:    this._object,
                           graph:     this._graph || &apos;&apos; });
    return next;
  },

  // ### `_readQuadPunctuation` reads punctuation after a quad.
  _readQuadPunctuation: function (token) {
    if (token.type !== &apos;.&apos;)
      return this._error(&apos;Expected dot to follow quad&apos;, token);
    return this._readInTopContext;
  },

  // ### `_readPrefix` reads the prefix of a prefix declaration.
  _readPrefix: function (token) {
    if (token.type !== &apos;prefix&apos;)
      return this._error(&apos;Expected prefix to follow @prefix&apos;, token);
    this._prefix = token.value;
    return this._readPrefixIRI;
  },

  // ### `_readPrefixIRI` reads the IRI of a prefix declaration.
  _readPrefixIRI: function (token) {
    if (token.type !== &apos;IRI&apos;)
      return this._error(&apos;Expected IRI to follow prefix &quot;&apos; + this._prefix + &apos;:&quot;&apos;, token);
    var prefixIRI;
    if (this._base === null || absoluteIRI.test(token.value))
      prefixIRI = token.value;
    else
      prefixIRI = this._resolveIRI(token);
    this._prefixes[this._prefix] = prefixIRI;
    this._prefixCallback(this._prefix, prefixIRI);
    return this._readDeclarationPunctuation;
  },

  // ### `_readBaseIRI` reads the IRI of a base declaration.
  _readBaseIRI: function (token) {
    if (token.type !== &apos;IRI&apos;)
      return this._error(&apos;Expected IRI to follow base declaration&apos;, token);
    try {
      this._setBase(this._base === null ||
                    absoluteIRI.test(token.value) ? token.value : this._resolveIRI(token));

      // BEGIN CHANGE
      this._prefixes[&quot;&quot;] = token.value;
      this._prefixCallback(&quot;&quot;, token.value);
      // END CHANGE
    }
    catch (error) { this._error(error.message, token); }
    return this._readDeclarationPunctuation;
  },

  // ### `_readNamedGraphLabel` reads the label of a named graph.
  _readNamedGraphLabel: function (token) {
    switch (token.type) {
    case &apos;IRI&apos;:
    case &apos;prefixed&apos;:
      return this._readSubject(token), this._readGraph;
    case &apos;[&apos;:
      return this._readNamedGraphBlankLabel;
    default:
      return this._error(&apos;Invalid graph label&apos;, token);
    }
  },

  // ### `_readNamedGraphLabel` reads a blank node label of a named graph.
  _readNamedGraphBlankLabel: function (token) {
    if (token.type !== &apos;]&apos;)
      return this._error(&apos;Invalid graph label&apos;, token);
    this._subject = &apos;_:b&apos; + blankNodeCount++;
    return this._readGraph;
  },

  // ### `_readDeclarationPunctuation` reads the punctuation of a declaration.
  _readDeclarationPunctuation: function (token) {
    // SPARQL-style declarations don&apos;t have punctuation.
    if (this._sparqlStyle)
      return this._readInTopContext(token);

    if (token.type !== &apos;.&apos;)
      return this._error(&apos;Expected declaration to end with a dot&apos;, token);
    return this._readInTopContext;
  },

  // ### `_getTripleEndReader` gets the next reader function at the end of a triple.
  _getTripleEndReader: function () {
    var stack = this._tripleStack;
    if (stack.length === 0)
      return this._readPunctuation;

    switch (stack[stack.length - 1].type) {
    case &apos;blank&apos;:
      return this._readBlankNodeTail;
    case &apos;list&apos;:
      return this._readListItem;
    }
  },

  // ### `_error` emits an error message through the callback.
  _error: function (message, token) {
    this._callback(new Error(message + &apos; at line &apos; + token.line + &apos;.&apos;));
  },

  // ### `_resolveIRI` resolves a relative IRI token against the base path,
  // assuming that a base path has been set and that the IRI is indeed relative.
  _resolveIRI: function (token) {
    var iri = token.value;
    switch (iri[0]) {
    // An empty relative IRI indicates the base IRI
    case undefined: return this._base;
    // Resolve relative fragment IRIs against the base IRI
    case &apos;#&apos;: return this._base + iri;
    // Resolve relative query string IRIs by replacing the query string
    case &apos;?&apos;: return this._base.replace(/(?:\?.*)?$/, iri);
    // Resolve root-relative IRIs at the root of the base IRI
    case &apos;/&apos;:
      // Resolve scheme-relative IRIs to the scheme
      return (iri[1] === &apos;/&apos; ? this._baseScheme : this._baseRoot) + this._removeDotSegments(iri);
    // Resolve all other IRIs at the base IRI&apos;s path
    default:
      return this._removeDotSegments(this._basePath + iri);
    }
  },

  // ### `_removeDotSegments` resolves &apos;./&apos; and &apos;../&apos; path segments in an IRI as per RFC3986.
  _removeDotSegments: function (iri) {
    // Don&apos;t modify the IRI if it does not contain any dot segments
    if (!dotSegments.test(iri))
      return iri;

    // Start with an imaginary slash before the IRI in order to resolve trailing &apos;./&apos; and &apos;../&apos;
    var result = &apos;&apos;, length = iri.length, i = -1, pathStart = -1, segmentStart = 0, next = &apos;/&apos;;

    while (i &lt; length) {
      switch (next) {
      // The path starts with the first slash after the authority
      case &apos;:&apos;:
        if (pathStart &lt; 0) {
          // Skip two slashes before the authority
          if (iri[++i] === &apos;/&apos; &amp;&amp; iri[++i] === &apos;/&apos;)
            // Skip to slash after the authority
            while ((pathStart = i + 1) &lt; length &amp;&amp; iri[pathStart] !== &apos;/&apos;)
              i = pathStart;
        }
        break;
      // Don&apos;t modify a query string or fragment
      case &apos;?&apos;:
      case &apos;#&apos;:
        i = length;
        break;
      // Handle &apos;/.&apos; or &apos;/..&apos; path segments
      case &apos;/&apos;:
        if (iri[i + 1] === &apos;.&apos;) {
          next = iri[++i + 1];
          switch (next) {
          // Remove a &apos;/.&apos; segment
          case &apos;/&apos;:
            result += iri.substring(segmentStart, i - 1);
            segmentStart = i + 1;
            break;
          // Remove a trailing &apos;/.&apos; segment
          case undefined:
          case &apos;?&apos;:
          case &apos;#&apos;:
            return result + iri.substring(segmentStart, i) + iri.substr(i + 1);
          // Remove a &apos;/..&apos; segment
          case &apos;.&apos;:
            next = iri[++i + 1];
            if (next === undefined || next === &apos;/&apos; || next === &apos;?&apos; || next === &apos;#&apos;) {
              result += iri.substring(segmentStart, i - 2);
              // Try to remove the parent path from result
              if ((segmentStart = result.lastIndexOf(&apos;/&apos;)) &gt;= pathStart)
                result = result.substr(0, segmentStart);
              // Remove a trailing &apos;/..&apos; segment
              if (next !== &apos;/&apos;)
                return result + &apos;/&apos; + iri.substr(i + 1);
              segmentStart = i + 1;
            }
          }
        }
      }
      next = iri[++i];
    }
    return result + iri.substring(segmentStart);
  },

  // ## Public methods

  // ### `parse` parses the N3 input and emits each parsed triple through the callback.
  parse: function (input, tripleCallback, prefixCallback) {
    // The read callback is the next function to be executed when a token arrives.
    // We start reading in the top context.
    this._readCallback = this._readInTopContext;
    this._prefixes = Object.create(null);
    this._prefixes._ = this._blankNodePrefix || &apos;_:b&apos; + blankNodePrefix++ + &apos;_&apos;;

    // If the input argument is not given, shift parameters
    if (typeof input === &apos;function&apos;)
      prefixCallback = tripleCallback, tripleCallback = input, input = null;

    // Set the triple and prefix callbacks.
    this._callback = tripleCallback || noop;
    this._prefixCallback = prefixCallback || noop;

    // Execute the read callback when a token arrives.
    var self = this;
    this._lexer.tokenize(input, function (error, token) {
      if (error !== null)
        self._callback(error), self._callback = noop;
      else if (self._readCallback !== undefined)
        self._readCallback = self._readCallback(token);
    });

    // If no input was given, it can be added with `addChunk` and ended with `end`
    if (!input) {
      this.addChunk = this._lexer.addChunk;
      this.end = this._lexer.end;
    }
  },
};

// The empty function
function noop() {}

// ## Exports

// Export the `N3Parser` class as a whole.
export default N3Parser;
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.7)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
