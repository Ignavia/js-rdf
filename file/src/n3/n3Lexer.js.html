<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/n3/n3Lexer.js | JavaScript RDF API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  <a href="./manual/index.html" data-ice="manualHeaderLink">Manual</a>
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/Ignavia/js-rdf.git" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/BlankNode.js~BlankNode.html">BlankNode</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Graph.js~Graph.html">Graph</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Literal.js~Literal.html">Literal</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/NamedNode.js~NamedNode.html">NamedNode</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/PrefixMap.js~PrefixMap.html">PrefixMap</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Profile.js~Profile.html">Profile</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/RDFEnvironment.js~RDFEnvironment.html">RDFEnvironment</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/RDFNode.js~RDFNode.html">RDFNode</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/TermMap.js~TermMap.html">TermMap</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Triple.js~Triple.html">Triple</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/TurtleReader.js~TurtleReader.html">TurtleReader</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/TurtleWriter.js~TurtleWriter.html">TurtleWriter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-xmlSchemaTypes">xmlSchemaTypes</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">n3</div><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-N3Lexer">N3Lexer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-N3Parser">N3Parser</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/n3/n3Lexer.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">// **N3Lexer** tokenizes N3 documents.
var fromCharCode = String.fromCharCode;
var immediately = typeof setImmediate === &apos;function&apos; ? setImmediate :
                  function setImmediate(func) { setTimeout(func, 0); };

// Regular expression and replacement string to escape N3 strings.
// Note how we catch invalid unicode sequences separately (they will trigger an error).
var escapeSequence = /\\u([a-fA-F0-9]{4})|\\U([a-fA-F0-9]{8})|\\[uU]|\\(.)/g;
var escapeReplacements = { &apos;\\&apos;: &apos;\\&apos;, &quot;&apos;&quot;: &quot;&apos;&quot;, &apos;&quot;&apos;: &apos;&quot;&apos;,
                           &apos;n&apos;: &apos;\n&apos;, &apos;r&apos;: &apos;\r&apos;, &apos;t&apos;: &apos;\t&apos;, &apos;f&apos;: &apos;\f&apos;, &apos;b&apos;: &apos;\b&apos;,
                           &apos;_&apos;: &apos;_&apos;, &apos;~&apos;: &apos;~&apos;, &apos;.&apos;: &apos;.&apos;, &apos;-&apos;: &apos;-&apos;, &apos;!&apos;: &apos;!&apos;, &apos;$&apos;: &apos;$&apos;, &apos;&amp;&apos;: &apos;&amp;&apos;,
                           &apos;(&apos;: &apos;(&apos;, &apos;)&apos;: &apos;)&apos;, &apos;*&apos;: &apos;*&apos;, &apos;+&apos;: &apos;+&apos;, &apos;,&apos;: &apos;,&apos;, &apos;;&apos;: &apos;;&apos;, &apos;=&apos;: &apos;=&apos;,
                           &apos;/&apos;: &apos;/&apos;, &apos;?&apos;: &apos;?&apos;, &apos;#&apos;: &apos;#&apos;, &apos;@&apos;: &apos;@&apos;, &apos;%&apos;: &apos;%&apos; };
var illegalIriChars = /[\x00-\x20&lt;&gt;\\&quot;\{\}\|\^\`]/;

// ## Constructor
function N3Lexer(options) {
  if (!(this instanceof N3Lexer))
    return new N3Lexer(options);

  // In line mode (N-Triples or N-Quads), only simple features may be parsed
  if (options &amp;&amp; options.lineMode) {
    // Don&apos;t tokenize special literals
    this._tripleQuotedString = this._number = this._boolean = /$0^/;
    // Swap the tokenize method for a restricted version
    var self = this;
    this._tokenize = this.tokenize;
    this.tokenize = function (input, callback) {
      this._tokenize(input, function (error, token) {
        if (!error &amp;&amp; /^(?:IRI|prefixed|literal|langcode|type|\.|eof)$/.test(token.type))
          callback &amp;&amp; callback(error, token);
        else
          callback &amp;&amp; callback(error || self._syntaxError(token.type, callback = null));
      });
    };
  }
}

N3Lexer.prototype = {
  // ## Regular expressions
  // It&apos;s slightly faster to have these as properties than as in-scope variables.

  _iri: /^&lt;((?:[^&gt;\\]|\\[uU])+)&gt;/, // IRI with escape sequences; needs sanity check after unescaping
  _unescapedIri: /^&lt;([^\x00-\x20&lt;&gt;\\&quot;\{\}\|\^\`]*)&gt;/, // IRI without escape sequences; no unescaping
  _unescapedString: /^&quot;[^&quot;\\]+&quot;(?=[^&quot;\\])/, // non-empty string without escape sequences
  _singleQuotedString: /^&quot;[^&quot;\\]*(?:\\.[^&quot;\\]*)*&quot;(?=[^&quot;\\])|^&apos;[^&apos;\\]*(?:\\.[^&apos;\\]*)*&apos;(?=[^&apos;\\])/,
  _tripleQuotedString: /^&quot;&quot;(&quot;[^&quot;\\]*(?:(?:\\.|&quot;(?!&quot;&quot;))[^&quot;\\]*)*&quot;)&quot;&quot;|^&apos;&apos;(&apos;[^&apos;\\]*(?:(?:\\.|&apos;(?!&apos;&apos;))[^&apos;\\]*)*&apos;)&apos;&apos;/,
  _langcode: /^@([a-z]+(?:-[a-z0-9]+)*)(?=[^a-z0-9\-])/i,
  _prefix: /^((?:[A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:\.?[\-0-9A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)?:(?=[#\s&lt;])/,
  _prefixed: /^((?:[A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:\.?[\-0-9A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)?:((?:(?:[0-:A-Z_a-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff]|%[0-9a-fA-F]{2}|\\[!#-\/;=?\-@_~])(?:(?:[\.\-0-:A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff]|%[0-9a-fA-F]{2}|\\[!#-\/;=?\-@_~])*(?:[\-0-:A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff]|%[0-9a-fA-F]{2}|\\[!#-\/;=?\-@_~]))?)?)(?=\.?[,;\s#()\[\]\{\}&quot;&apos;&lt;])/,
  _blank: /^_:((?:[0-9A-Z_a-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:\.?[\-0-9A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)(?=\.?[,;:\s#()\[\]\{\}&quot;&apos;&lt;])/,
  _number: /^[\-+]?(?:\d+\.?\d*([eE](?:[\-\+])?\d+)|\d*\.?\d+)(?=[.,;:\s#()\[\]\{\}&quot;&apos;&lt;])/,
  _boolean: /^(?:true|false)(?=[.,;:\s#()\[\]\{\}&quot;&apos;&lt;])/,
  _keyword: /^@[a-z]+(?=[\s#&lt;:])/,
  _sparqlKeyword: /^(?:PREFIX|BASE|GRAPH)(?=[\s#&lt;:])/i,
  _shortPredicates: /^a(?=\s+|&lt;)/,
  _newline: /^[ \t]*(?:#[^\n\r]*)?(?:\r\n|\n|\r)[ \t]*/,
  _whitespace: /^[ \t]+/,
  _endOfFile: /^(?:#[^\n\r]*)?$/,

  // ## Private methods

  // ### `_tokenizeToEnd` tokenizes as for as possible, emitting tokens through the callback.
  _tokenizeToEnd: function (callback, inputFinished) {
    // Continue parsing as far as possible; the loop will return eventually.
    var input = this._input;
    while (true) {
      // Count and skip whitespace lines.
      var whiteSpaceMatch;
      while (whiteSpaceMatch = this._newline.exec(input))
        input = input.substr(whiteSpaceMatch[0].length, input.length), this._line++;
      // Skip whitespace on current line.
      if (whiteSpaceMatch = this._whitespace.exec(input))
        input = input.substr(whiteSpaceMatch[0].length, input.length);

      // Stop for now if we&apos;re at the end.
      if (this._endOfFile.test(input)) {
        // If the input is finished, emit EOF.
        if (inputFinished)
          callback(input = null, { line: this._line, type: &apos;eof&apos;, value: &apos;&apos;, prefix: &apos;&apos; });
        return this._input = input;
      }

      // Look for specific token types based on the first character.
      var line = this._line, type = &apos;&apos;, value = &apos;&apos;, prefix = &apos;&apos;,
          firstChar = input[0], match = null, matchLength = 0, unescaped, inconclusive = false;
      switch (firstChar) {
      case &apos;^&apos;:
        // Try to match a type.
        if (input.length === 1) break;
        else if (input[1] !== &apos;^&apos;) return reportSyntaxError(this);
        this._prevTokenType = &apos;^&apos;;
        // Move to type IRI or prefixed name.
        input = input.substr(2);
        if (input[0] !== &apos;&lt;&apos;) {
          inconclusive = true;
          break;
        }
        // Fall through in case the type is an IRI.

      case &apos;&lt;&apos;:
        // Try to find a full IRI without escape sequences.
        if (match = this._unescapedIri.exec(input))
          type = &apos;IRI&apos;, value = match[1];
        // Try to find a full IRI with escape sequences.
        else if (match = this._iri.exec(input)) {
          unescaped = this._unescape(match[1]);
          if (unescaped === null || illegalIriChars.test(unescaped))
            return reportSyntaxError(this);
          type = &apos;IRI&apos;, value = unescaped;
        }
        break;

      case &apos;_&apos;:
        // Try to find a blank node. Since it can contain (but not end with) a dot,
        // we always need a non-dot character before deciding it is a prefixed name.
        // Therefore, try inserting a space if we&apos;re at the end of the input.
        if ((match = this._blank.exec(input)) ||
            inputFinished &amp;&amp; (match = this._blank.exec(input + &apos; &apos;)))
          type = &apos;prefixed&apos;, prefix = &apos;_&apos;, value = match[1];
        break;

      case &apos;&quot;&apos;:
      case &quot;&apos;&quot;:
        // Try to find a non-empty double-quoted literal without escape sequences.
        if (match = this._unescapedString.exec(input))
          type = &apos;literal&apos;, value = match[0];
        // Try to find any other literal wrapped in a pair of single or double quotes.
        else if (match = this._singleQuotedString.exec(input)) {
          unescaped = this._unescape(match[0]);
          if (unescaped === null)
            return reportSyntaxError(this);
          type = &apos;literal&apos;, value = unescaped.replace(/^&apos;|&apos;$/g, &apos;&quot;&apos;);
        }
        // Try to find a literal wrapped in three pairs of single or double quotes.
        else if (match = this._tripleQuotedString.exec(input)) {
          unescaped = match[1] || match[2];
          // Count the newlines and advance line counter.
          this._line += unescaped.split(/\r\n|\r|\n/).length - 1;
          unescaped = this._unescape(unescaped);
          if (unescaped === null)
            return reportSyntaxError(this);
          type = &apos;literal&apos;, value = unescaped.replace(/^&apos;|&apos;$/g, &apos;&quot;&apos;);
        }
        break;

      case &apos;@&apos;:
        // Try to find a language code.
        if (this._prevTokenType === &apos;literal&apos; &amp;&amp; (match = this._langcode.exec(input)))
          type = &apos;langcode&apos;, value = match[1];
        // Try to find a keyword.
        else if (match = this._keyword.exec(input))
          type = match[0];
        break;

      case &apos;.&apos;:
        // Try to find a dot as punctuation.
        if (input.length === 1 ? inputFinished : (input[1] &lt; &apos;0&apos; || input[1] &gt; &apos;9&apos;)) {
          type = &apos;.&apos;;
          matchLength = 1;
          break;
        }
        // Fall through to numerical case (could be a decimal dot).

      case &apos;0&apos;:
      case &apos;1&apos;:
      case &apos;2&apos;:
      case &apos;3&apos;:
      case &apos;4&apos;:
      case &apos;5&apos;:
      case &apos;6&apos;:
      case &apos;7&apos;:
      case &apos;8&apos;:
      case &apos;9&apos;:
      case &apos;+&apos;:
      case &apos;-&apos;:
        // Try to find a number.
        if (match = this._number.exec(input)) {
          type = &apos;literal&apos;;
          value = &apos;&quot;&apos; + match[0] + &apos;&quot;^^http://www.w3.org/2001/XMLSchema#&apos; +
                  (match[1] ? &apos;double&apos; : (/^[+\-]?\d+$/.test(match[0]) ? &apos;integer&apos; : &apos;decimal&apos;));
        }
        break;

      case &apos;B&apos;:
      case &apos;b&apos;:
      case &apos;p&apos;:
      case &apos;P&apos;:
      case &apos;G&apos;:
      case &apos;g&apos;:
        // Try to find a SPARQL-style keyword.
        if (match = this._sparqlKeyword.exec(input))
          type = match[0].toUpperCase();
        else
          inconclusive = true;
        break;

      case &apos;f&apos;:
      case &apos;t&apos;:
        // Try to match a boolean.
        if (match = this._boolean.exec(input))
          type = &apos;literal&apos;, value = &apos;&quot;&apos; + match[0] + &apos;&quot;^^http://www.w3.org/2001/XMLSchema#boolean&apos;;
        else
          inconclusive = true;
        break;

      case &apos;a&apos;:
        // Try to find an abbreviated predicate.
        if (match = this._shortPredicates.exec(input))
          type = &apos;abbreviation&apos;, value = &apos;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&apos;;
        else
          inconclusive = true;
        break;

      case &apos;,&apos;:
      case &apos;;&apos;:
      case &apos;[&apos;:
      case &apos;]&apos;:
      case &apos;(&apos;:
      case &apos;)&apos;:
      case &apos;{&apos;:
      case &apos;}&apos;:
        // The next token is punctuation
        matchLength = 1;
        type = firstChar;
        break;

      default:
        inconclusive = true;
      }

      // Some first characters do not allow an immediate decision, so inspect more.
      if (inconclusive) {
        // Try to find a prefix.
        if ((this._prevTokenType === &apos;@prefix&apos; || this._prevTokenType === &apos;PREFIX&apos;) &amp;&amp;
            (match = this._prefix.exec(input)))
          type = &apos;prefix&apos;, value = match[1] || &apos;&apos;;
        // Try to find a prefixed name. Since it can contain (but not end with) a dot,
        // we always need a non-dot character before deciding it is a prefixed name.
        // Therefore, try inserting a space if we&apos;re at the end of the input.
        else if ((match = this._prefixed.exec(input)) ||
                 inputFinished &amp;&amp; (match = this._prefixed.exec(input + &apos; &apos;)))
          type = &apos;prefixed&apos;, prefix = match[1] || &apos;&apos;, value = this._unescape(match[2]);
      }

      // A type token is special: it can only be emitted after an IRI or prefixed name is read.
      if (this._prevTokenType === &apos;^&apos;)
        type = (type === &apos;IRI&apos; || type === &apos;prefixed&apos;) ? &apos;type&apos; : &apos;&apos;;

      // What if nothing of the above was found?
      if (!type) {
        // We could be in streaming mode, and then we just wait for more input to arrive.
        // Otherwise, a syntax error has occurred in the input.
        // One exception: error on an unaccounted linebreak (= not inside a triple-quoted literal).
        if (inputFinished || (!/^&apos;&apos;&apos;|^&quot;&quot;&quot;/.test(input) &amp;&amp; /\n|\r/.test(input)))
          return reportSyntaxError(this);
        else
          return this._input = input;
      }

      // Emit the parsed token.
      callback(null, { line: line, type: type, value: value, prefix: prefix });
      this._prevTokenType = type;

      // Advance to next part to tokenize.
      input = input.substr(matchLength || match[0].length, input.length);
    }

    // Signals the syntax error through the callback
    function reportSyntaxError(self) { callback(self._syntaxError(/^\S*/.exec(input)[0])); }
  },

  // ### `_unescape` replaces N3 escape codes by their corresponding characters.
  _unescape: function (item) {
    try {
      return item.replace(escapeSequence, function (sequence, unicode4, unicode8, escapedChar) {
        var charCode;
        if (unicode4) {
          charCode = parseInt(unicode4, 16);
          if (isNaN(charCode)) throw new Error(); // can never happen (regex), but helps performance
          return fromCharCode(charCode);
        }
        else if (unicode8) {
          charCode = parseInt(unicode8, 16);
          if (isNaN(charCode)) throw new Error(); // can never happen (regex), but helps performance
          if (charCode &lt;= 0xFFFF) return fromCharCode(charCode);
          return fromCharCode(0xD800 + ((charCode -= 0x10000) / 0x400), 0xDC00 + (charCode &amp; 0x3FF));
        }
        else {
          var replacement = escapeReplacements[escapedChar];
          if (!replacement)
            throw new Error();
          return replacement;
        }
      });
    }
    catch (error) { return null; }
  },

  // ### `_syntaxError` creates a syntax error for the given issue
  _syntaxError: function (issue) {
    this._input = null;
    return new Error(&apos;Syntax error: unexpected &quot;&apos; + issue + &apos;&quot; on line &apos; + this._line + &apos;.&apos;);
  },


  // ## Public methods

  // ### `tokenize` starts the transformation of an N3 document into an array of tokens.
  // The input can be a string or a stream.
  tokenize: function (input, callback) {
    var self = this;
    this._line = 1;

    // If the input is a string, continuously emit tokens through the callback until the end.
    if (typeof input === &apos;string&apos;) {
      this._input = input;
      immediately(function () { self._tokenizeToEnd(callback, true); });
    }
    // Otherwise, the input will be streamed.
    else {
      this._input = &apos;&apos;;

      // If no input was given, it will be streamed through `addChunk` and ended with `end`
      if (!input || typeof input === &apos;function&apos;) {
        this.addChunk = addChunk;
        this.end = end;
        if (!callback)
          callback = input;
      }
      // Otherwise, the input itself must be a stream
      else {
        if (typeof input.setEncoding === &apos;function&apos;)
          input.setEncoding(&apos;utf8&apos;);
        input.on(&apos;data&apos;, addChunk);
        input.on(&apos;end&apos;, end);
      }
    }

    // Adds the data chunk to the buffer and parses as far as possible
    function addChunk(data) {
      if (self._input !== null) {
        self._input += data;
        self._tokenizeToEnd(callback, false);
      }
    }

    // Parses until the end
    function end() {
      if (self._input !== null)
        self._tokenizeToEnd(callback, true);
    }
  },
};

// ## Exports

// Export the `N3Lexer` class as a whole.
export default N3Lexer;
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.7)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
